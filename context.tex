% !TEX root = main.tex

\chapter{Context}
\label{cha:context}


A distributed system can be defined as a set of independent entities that work together to solve a problem. They are characterized by not having a common physical clock, no shared memory, geographical separation, autonomy, and heterogeneity \cite{alma991001697099707681}.
In the context of distributed computing, these independent entities are computers, or nodes, communicating across the internet or any other network. Having no shared memory means that computers need to communicate their data in order to carry out procedures. When you sign in to a website, your credentials are sent across the internet to a server that reads those credentials and validates them. Even loading up a webpage requires data transfer, by typing the URL into a browser, that domain name is translated into a web server somewhere that sends back the necessary HTML, CSS, and JavaScript files to display the page. Another example of distributed systems is the microservices architectural pattern. This pattern is used in many cloud computing applications and involves the use of isolated services that have limited responsibilities. Each microservice lives on a specific node and communicates with other services to carry out the goals of the system. Communication in such a setting is usually done through an API or a remote procedure call. We note that data transfer is ubiquitous in both scenarios, and all different types of distributed computing systems.

The rise of distributed computing brought along the rise of tools to develop these systems.
Different programming languages can be used to implement distributed systems, however, there are programming languages that facilitate the implementation of common patterns and computation models unique to distribution. One of the most successful languages designed with this goal in mind is Erlang, a functional language inspired by Lisp and developed for use in the telecommunications company Ericsson. Another such language, less successful than Erlang but still interesting because of the ideas it put forth, is Emerald \cite{BlackAndrew2007Tdot}. Emerald is an object-oriented language focused on distribution. One of the main features of Emerald is the fine control over the location of objects within the distributed system, where programmers, or the compiler itself, can manage the movement of objects across computational nodes.

Emerald identifies a few choices for parameter passing semantics \cite{JulEric1988Fmit}, of which three are of importance to our work. The first is \textit{pass-by-reference} (referred to as \textit{call-by-object-reference} in Emerald), which consists of passing a reference to the object when a function is invoked. This means that an object is not moved within the Emerald system when a function is called, and it is up to the system to decide what to do once it is necessary to read the contents of the referenced object. This stands in contrast to the second method, \textit{pass-by-value} (referred to as \textit{call-by-value} in Emerald), which corresponds to passing the value of an object to a function calling that object. \textit{Pass-by-value} is not used by Emerald but is used by almost all other systems, since references to remote objects do not make much sense in a system that has a different environment per node of distribution. The third object mobility method, introduced along with Emerald, is \textit{pass-by-move} (referred to as \textit{call-by-move} in the original paper). This method involves the colocation of an object with the method that was invoking it, making it useful for situations where that object would be repeatedly accessed since remote invocations are more costly than local invocations. 