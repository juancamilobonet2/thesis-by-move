% !TEX root = main.tex

\chapter{Context}
\label{cha:context}


A distributed system can be defined as a set of independent entities that work together to solve a problem. They are characterized by not having a common physical clock, no shared memory, geographical separation, and autonomy and heterogeneity \cite{alma991001697099707681}.
In the context of distributed computing, these independent entities are computers communicating across the internet or any other network. Having no shared memory means that computers need to communicate their data in order to carry out procedures. When you sign in to a website, your credentials are sent across the internet to a server that reads those credentials and validates them. Even loading up a webpage requires data transfer, by typing the URL into a browser, that domain name is translated into a web server somewhere that sends back the necessary HTML, CSS, and JavaScript files to display the page. Another example is the microservices architectural pattern. This is used in many cloud computing applications and involves the use of isolated services that have limited responsibilities. Each microservice lives on a specific machine and communicates with other services to carry out the goals of the system. Communication in this setting is usually done through an API or a remote procedure call. Again we see that data transfer is ubiquitous in all forms of distributed computing systems.

The rise of distributed computing brought along with it the rise of tools to develop these systems. Any language can be used to implement a distributed system, but it quickly became clear that it would be more convenient and efficient to have a programming language which facilitated the implementation of common patterns and computation models unique to distribution. One of the most successful languages designed with this goal in mind was Erlang, a functional language inspired by Lisp and developed by and intended for use in the telecommunications company Ericsson. Another such language, less successful than Erlang but still interesting because of the ideas it put forth, was Emerald \cite{BlackAndrew2007Tdot}. Emerald was an object-oriented language that focused on distribution. One of the features of this system was the fine control over the location of objects within the distributed system. If the programmer wished to do so, they could forget about the movement of objects and let the compiler manage this movement, but they could also explicitly choose how objects moved.

Emerald identifies a few choices for parameter passing semantics \cite{JulEric1988Fmit}, of which three are of importance to this project. The first is \textit{pass-by-reference} (referred to as \textit{call-by-object-reference} in the original paper), which consists of passing a reference to the object when a function is invoked. This means that an object is not moved within the Emerald system when a function is called, and it is up to the system to decide what to do once it is necessary to read the contents of the referenced object. This stands in contrast to the second method, \textit{pass-by-value} (referred to as \textit{call-by-value} in the original paper), which corresponds to passing the value of an object to a function calling that object. \textit{Pass-by-value} is not used by Emerald but is used by almost all other systems, since references to remote objects don't make much sense in a system that has a different environment per node of distribution. The third method, introduced along with Emerald, was \textit{pass-by-move} (referred to as \textit{call-by-move} in the original paper). This method involved the colocation of an object with the method that was invoking it, making it useful for situations where that object would be repeatedly accessed since remote invocations are more costly than local invocations. 

% idk if the problem goes here...