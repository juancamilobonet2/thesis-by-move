% $Id: introduction.tex 1784 2012-04-27 23:29:31Z nicolas.cardozo $
% !TEX root = main.tex

\chapter{Introduction}
\label{cha:introduction}



%Parrafo contexto
Distributed systems are everywhere in today's world. Cloud computing, communications infrastructure, internet of things, and microservices are just a few examples of distributed computing in practice. Characteristic to these architectures is that functions permanently live on a single machine and data is mobilized between computers in order to carry out tasks that are required of the system. For example, one might have a microservice that deals with user authentication and another that handles requests based on the user's permissions. These microservices might be a single machine or many depending on the architecture, but the code that is loaded on each machine is static and is only changed when updating the system. Machines communicate can communicate in many different ways, like Rest APIs or remote procedure calls, but fundamentally only data is shared between processes.


There are several issues directly caused by the static nature of functions in a distributed system. Shared state is undesirable and can lead to improper and unpredictable behaviors. Moreover, if you are sending vast amounts of data for an operation that doesn't require much computational power, it can be advantageous to perform the computations on the same device that has the information. This is a core principle of fog computing, an architecture that values computation on edge devices rather than in the cloud when applicable. Sending data is also troublesome when considering data security, as it gives attackers more avenues to tap into and inspect sensitive data.

Given all of these objections, one might consider a model where functions are mobile between distributed nodes rather than data. To do this, we need a way to pass functions between nodes as easily as one would pass regular data. Since functions encapsulate a sequence of instructions, what we really want is to pass these instructions between nodes. Moreover, we must consider the mechanism by which these instructions are sent, and how the programmer interacts with this as part of a larger framework. 

In this paper we present an implementation and validation of such a system, written in Elixir and using pass-by-move semantics for function mobility between nodes. This implementation uses the metaprogramming capabilities of Elixir and can be adapted to any distributed system by making use of the defined macros and functions.

In order to validate the proposed solution, we implement a simple distributed application in a conventional way and in a way that makes use of our solution. We compare the network load on the entire system depending on how many petitions need to be processed. We show that when dealing with a larger amount of data, the proposed solution leads to lower network load than the traditional approach.


\endinput

